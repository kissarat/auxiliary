<!DOCTYPE html>
<html>
    <head>
        <title>Petri Network</title>
        <script src="../../basic.js"></script>
        <script src="../../generate.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
        <style>
            #toolbox {
                position: fixed;
                top: 0;
                right: 0;
                width: 200px;
            }

            .target-name {
                height: 22px;
            }

            .target-name input {
                width: 80px;
            }
        </style>
    </head>
    <body>
        <h1>Petri Network</h1>
        <template>

        </template>
        <div id="app">
            <svg width="600" height="600" xmlns="http://www.w3.org/2000/svg"
            v-on:mousemove="move(...coordinatesOf($event))"
            v-on:mousedown="down($event)"
            v-on:mouseup="up(...coordinatesOf($event))"
            >
                <path v-bind:d="grid" stroke="rgba(0, 0, 0, 0.2)" />
                <path v-bind:d="activeArrow" stroke="black" />
                <g>
                    <rect v-if="selection"
                        v-bind:x="offset(selection.x)"
                        v-bind:y="offset(selection.y)"
                        v-bind:width="scale"
                        v-bind:height="scale"
                        fill="transparent"
                        stroke="rgba(0, 0, 0, 0.6)"
                    />
                    <g v-bind:id="id" v-for="{x, y, id, to} of nodes">
                        <circle
                            v-bind:r="radius"
                            v-bind:fill="isSelected(id) ? 'black' : 'rgba(0, 0, 0, 0.7)'"
                            v-bind:cx="cof(x)"
                            v-bind:cy="cof(y)"
                        />
                        <path v-for="toNode of getNodesById(...to)"
                            stroke="black"
                            v-bind:d="arrow(x, y, toNode.x, toNode.y)"
                        />
                    </g>
                </g>
            </svg>
            <div id="toolbox">
                <div class="target-name">
                    Selected:
                    <input v-if="target" v-model="target.id" />
                </div>
                <button v-on:click="add()">Add</button>
                <button v-on:click="remove()"
                    v-bind:disabled="!this.selection">Remove</button>
                <button v-on:click="reset()">Clear</button>
            </div>
        </div>
        <script>
            const cellSize = 24;
            const arrowOffset = cellSize * 3/4 - 2;
            function* grid(size, scale = cellSize) {
                const end = size * scale;
                for(const i of range(size)) {
                    const j = i * scale;
                    yield `M 0 ${j} H ${end}`;
                }
                for(const i of range(size)) {
                    const j = i * scale;
                    yield `M ${j} 0 V ${end}`;
                }
            }
            const svg = document.querySelector('svg');
            const box = svg.getBoundingClientRect();
            const numberOf = x => Math.floor(x / cellSize);
            // center of
            const cof = i => i * cellSize + cellSize / 2;
            let objectId = 0;

            class Point {
                constructor(x = 0, y = 0) {
                    this.x = x;
                    this.y = y;
                }

                scale(s) {
                    return new Point(this.x * s, this.y * s);
                }
            }

            class Vector extends Point {
                constructor(x = 0, y = 0, offset = new Point()) {
                    super(x, y);
                    this.offset = offset;
                }
            }

            function createId(prefix = 'n') {
                return prefix + objectId++;
            }

            // const enabled = node => node && node.enabled;

            class Node {
                constructor(id = createId()) {
                    this.id = id;
                    // this.enabled = true;
                }

                describe() {
                    return `${this.constructor}(${this.id})`;
                }
            }

            function stringify(object) {
                return object.toString();
            }

            class Place extends Node {
                constructor(tokenCount = 0, id = createId('s')) {
                    super(id);
                    this.tokenCount = tokenCount;
                }

                increment() {
                    this.tokenCount++;
                }

                decrement() {
                    if (this.active) {
                        this.tokenCount--;
                    } else {
                        throw new Error(`${this.describe()}: negative token count`)
                    }
                }

                toString() {
                    return `${this.id}=${this.tokenCount}`;
                }

                describe() {
                    return `place(${this.toString()})`;
                }

                get active() {
                    return this.tokenCount > 0;
                }
            }

            Place.create = function(string) {
                const [id, count] = string.split('=');
                return new Place(
                    +count || 0,
                    id
                )
            }

            class Transition extends Node {
                constructor(input = [], output = [], id = createId('t')) {
                    super(id);
                    this.input = input;
                    this.output = output;
                }

                fire() {
                    if (this.input.every(p => p.active)) {
                        for(const place of this.input) {
                            place.decrement();
                        }
                        for(const place of this.output) {
                            place.increment();
                        }
                        return true;
                    }
                    return false;
                }

                toString() {
                    return `${this.id}: ${this.input.join(',')} -> ${this.output.join(',')}`;
                }

                describe() {
                    return `transition(${this.toString()})`;
                }
            }

            Transition.create = function(string) {
                const [id, io] = string.split(':');
                const [input, output] = io.split('->');
                return new Transition(
                    input.split(','),
                    output.split(','),
                    id
                )
            }

            class Network {
                constructor(places = [], transitions = []) {
                    this.places = places;
                    this.transitions = transitions;
                }

                fire() {
                    return this.transitions.some(t => t.fire());
                }

                run(n = LastNumber) {
                    for(let i = 0; i < n && this.fire(); i++) {}
                }

                toString() {
                    return [
                        ...this.places.map(stringify),
                        ...this.transitions.map(stringify)
                    ].join(';\n');
                }

                toJSONString() {
                    return JSON.stringify(this, null, '  ');
                }
            }

            Network.create = function(string) {
                const statements = string
                    .replace(/[ \t]+/g, '')
                    .split(/\s*;+\s*/)
                const transitions = [];
                const places = [];
                let i = 0;
                for(const s of statements) {
                    if ('#' === s[0] || s.length === 0) {
                        continue;
                    }
                    if (s.includes('->')) {
                        transitions.push(Transition.create(s));
                    } else if (s.includes('=') || /^\w+$/.test(s)) {
                        places.push(Place.create(s));
                    } else {
                        console.error(`Unknown syntax at ${i}: ${s}`)
                    }
                    i++;
                }
                return new Network(
                    places,
                    transitions
                );
            }

            const network = Network.create(`p1=1; p2=1; p3;
                t1: p1,p2 -> p3;
                t2: p3 -> p2`);

            const node = (x = 0, y = x) => ({
                to: [],
                x,
                y,
                id: `n${objectId++}`
            });
            const defaultNode = node();
            let nodes;
            function reset() {
                app.nodes.splice(0);
                objectId = 1;
                localStorage.clear();
            }
            try {
                nodes = JSON.parse(localStorage.getItem('nodes'));
                if (!Array.isArray(nodes)) {
                    throw Error();
                }
            } catch(ex) {
                reset();
            }
            const lastObjectId = nodes
                .map(n => (n.id && 'n' === n.id[0] && +n.id.slice(1)) || 0)
                .reduce((a, b) => Math.max(a, b), 0);
            if (lastObjectId >= objectId) {
                objectId = lastObjectId + 1;
            }

            const Modes = {
                Nothing: '',
                Move: 'move',
                Graph: 'graph',
            }

            function coordinatesOf(e) {
                return [numberOf(e.offsetX), numberOf(e.offsetY)];
            }

            function pointAt(x1, y1, x2, y2, offset) {
                const x = x2 - x1;
                const y = y2 - y1;
                const length = Math.sqrt(x**2 + y**2);
                const d = (offset > 0 ? offset : (length + offset)) / length;
                const ax = x1 + x * d;
                const ay = y1 + y * d;
                return [ax, ay];
            }
            
            const segment = fn => (x1, y1, x2, y2) => fn(cof(x1), cof(y1), cof(x2), cof(y2));
            const rawLine = (x1, y1, x2, y2) => `M ${x1} ${y1} L ${x2} ${y2}`;
            const line = segment(rawLine);
            function rawArrow(x1, y1, x2, y2) {
                return rawLine(
                    ...pointAt(x1, y1, x2, y2, arrowOffset),
                    ...pointAt(x1, y1, x2, y2, -arrowOffset)
                );
            }
            const arrow = segment(rawArrow);

            const app = new Vue({
                el: '#app',
                data: {
                    scale: cellSize,
                    grid: array(grid(20)).join(' '),
                    radius: cellSize / 2,
                    nodes,
                    mode: Modes.Nothing,
                    activeArrow: '',
                    target: null
                },
                computed: {
                    selection() {
                        return this.target || null;
                    },
                    targetId() {
                        return this.target ? this.target.id : '';
                    }
                },
                methods: {
                    cof,
                    reset,
                    coordinatesOf,
                    line,
                    arrow,
                    getById(id) {
                        return this.nodes.find(n => n.id === id);
                    },
                    addTo(id) {
                        if (!this.isSelected(id) && !this.target.to.find(n => n.id === id)) {
                            this.target.to.push(id);
                        }
                    },
                    offset(x) {
                        return x * cellSize;
                    },
                    isSelected(id) {
                        return this.target && this.target.id === id;
                    },
                    *getNodesById(...ids) {
                        for(const id of ids) {
                            const node = this.getById(id);
                            if (node) {
                                yield node;
                            }
                        }
                    },
                    detect(x, y) {
                        return this.nodes.find(n => n.x === x && n.y === y);
                    },
                    add() {
                        this.nodes.push(node());
                    },
                    remove() {
                        const id = this.targetId;
                        this.nodes = this.nodes.filter(n => n.id !== id);
                    },
                    down(e) {
                        const node = this.detect(...coordinatesOf(e));
                        if (node) {
                            this.target = node;
                            this.mode = e.ctrlKey ? Modes.Graph : Modes.Move;
                        }
                    },
                    up(x, y) {
                        switch(this.mode) {
                            case Modes.Graph:
                                this.activeArrow = '';
                                const node = this.detect(x, y);
                                if (node) {
                                    this.addTo(node.id);
                                }
                                break;
                        }
                        this.mode = Modes.Nothing;
                    },
                    move(x, y) {
                        if (this.target) {
                            switch(this.mode) {
                                case Modes.Move:
                                    this.target.x = x;
                                    this.target.y = y;
                                    break;
                                case Modes.Graph:
                                    this.activeArrow = arrow(
                                        this.target.x, this.target.y,
                                        x, y
                                    );
                                    break;
                            }
                        }
                    }
                }
            })
            onunload = () => localStorage.setItem('nodes',
                JSON.stringify(app.nodes.map(chain(pick, 'id', 'to', 'x', 'y'))));
        </script>
    </body>
</html>
